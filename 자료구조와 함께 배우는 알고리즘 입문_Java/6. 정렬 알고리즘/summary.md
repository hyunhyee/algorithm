___
# What is sorting? 
대소 관계에 따라 데이터 집합을 일정한 순서로 나열

* - 오름차순 : 작은 데이터가 앞
  - 내림차순

*  안정된 정렬 : 같은 값을 정렬해도 그 전의 순서가 유지되는 것

* - 내부정렬 : 데이터 개수가 상대적으로 적을 때
  - 외부정렬 : 데이터가 많아서 하나의 배열 이상 필요시

* 핵심 요소: 교환, 선택, 삽입

___
# 버블정렬 bubble sort 
(=단순 교환 정렬 straight exchange sort) 이웃한 두 요소의 대소 관계를 비교하고 필요에 대한 교환을 반복

* if 가장 작은 값을 앞으로 보내려고 한다면, 데이터 개수가 n개라면 n-1 번 비교 -> 가장 작은 값이 맨 앞에 정렬됨
* 비교하고 자리를 바꾸는 것을 pass
* 두 번째 자리에 원하는 값(두 번째로 작은 값을 넣는)을 넣기 위해선 n-2번 pass가 진행됨
* 그리고 모든 정렬이 끝나려면 n-1번의 pass가 진행되는데 마지막 값은 비교없이 마지막에 위치하니까

### 버블 정렬 프로그램 만들기
* 변수 i값을 0부터 n-2까지 1씩 증가시키며 패스를 n-1번 수행하는 프로그램

❗ n-2 왜냐면 배열은 0부터 시작하니까 n값을 넣으면 n-1 값까지만 비교하면 되는데 배열안의 숫자는 그것보다 -1 해야되므로

```java
for(int i =0; i<n-1;i++){

}
 📍 이렇게 무작위로 배열값을 나열하고 뒤에서 앞으로 비교& 자리를 바꾸는 코드를 작성한다.

'''java
class BubbleSort{
static void swap(int[] 1, int idx1, int idx2} {
int t = a[idx1]
a[idx1] = a[idx2];
a[idx2] = t;
} //비교한 두 값을 교환

static void bubbleSort(int[] a, int n){
for(int i =0; i<n-1; i++)
for(int j= n-1; j>i; j--)
if(a[[j-1] > a[j])
swap(a, j-1, j);
}
```

### 알고리즘 개선하기1

상황) 뒤에서부터 비교하다가 중간부터 교환이 필요없을 때 (이미 정렬이 된 상태), 정렬의 진행을 멈추기 위한 방법

❓p 207 어떤 패스에서 요소의 교환 횟수가 0번이면 더이상 정렬할 요소가 없다는 뜻

❓  
1. 변수 exchg 새롭게 추가  
2. 패스 전  exchg = 0; -> 요소 교환시 +1 즉, 패스 종료한(안쪽 for 반복이 완료시) 변수 exchg값은 해당 패스의 교환 횟수  
3. 패스 종료시 exchg =0 이면 정렬이 완료 -> 함수 종료  

❓ p 206 q2 출력 패스1 1,8은 교환 이루어지지 않는데 왜 멈추지 않고 진행

### 알고리즘 개선하기2  
last = 패스시 오른쪽 인덱스를 저장하는 변수 -> ❓last를 k에 대입하여 다음에 수행할 패스의 범위 제한  
❗마지막 교환이 일어난 인덱스는 제외하고 정렬하는 것
___
# 단순 선택 정렬(straight selection sort) 
* 가장 작은 요소를 맨 앞, 두 번째 작은 요소는 맨 앞에서 두 번째로 이동하는 작업을 반복
가장 작은 값을 선택 후 맨 앞에 넣기 -> 두 번째 작은 요소를 그 다음에 넣기

❓ 실습 6-4 swap전까지는 가장 작은 값을 찾는 메서드인가? 아직 정렬은 안하고? => Yes
___
# 단순 삽입 정렬(straight insertion sort) 
* 아직 정렬되지 않은 부분의 첫 번째 요소를 정렬한 부분의 알맞은 위치에 삽입

* 단순삽입 정렬은 두 번째 요소부터 선택하여 진행

* 알맞은 위치에 삽입? 이웃한 요소를 비교하면서 위치를 교환하여 원하는 곳에 삽입하는 것

___
# 셸 정렬
단순 삽입 정렬의 장점을 살리고 단점을 보완하여 스피드 UP

 -단순 삽입 정렬 복습!
 장점: 정렬되어 있거나 정렬 상태가 가까우면 속도가 빠르지만
 단점: 삽입할 곳이 멀리 있으면 pass 횟수가 많아진다.
 
 그럼 셸 정렬이란?
 
 정렬을 큰 2개의 그룹으로 나누고
 1번 그룹의 맨앞 vs 2번 그룹의 맨앞 pass
 
 그리고 정렬을 더 작은 큰 그룹으로 나누고
 1번 그룹의 맨앞 vs 2번 그룹의 맨앞 pass vs 3번 그룹의 맨앞 pass
 
 -> 조금이라도 더 '정렬된'상태에서 단순 삽입 정렬 사용
 
 ```dart
 // 
 class ShellSort {
     static void shellSort(int[] a, int n) { 📍배열 x = a와 배열 x의 길이값 nx = n를 shellSort 메소드로 실행
        for (int h = n / 2; h > 0; h /= 2)   📍h = 길이를 반으로 나누고, 만약 반으로 나눈 값이 0보다 크면
            for (int i = h; i < n; i++) {    📍 반으로 나눠진 값을 i에 넣고, i값이 n보다 작으면
                int j;                   
                int tmp = a[i];              📍tmp에 a배열의 나눠진 중간 배열의 값을 넣고
                
                for (j = i - h; j >= 0 && a[j] > tmp; j -= h)  ❓근데 왜 여기서 j값을 넣어주지? int j = i로 하면 안되나?  
                    a[j + h] = a[j];
                 a[j + h] = tmp;
            }
    }
    
  📢 이중 for문
  h = n/2 가 조건 h>0에 해당하면
  i = h에 넣고 조건 i<n에 해당하면
  j = i-h를 넣고 조건 j>=0&& a[j]>tmp에 해당하면  a[j + h] = a[j]; a[j + h] = tmp; 실행하고
  j에 j-h값을 넣고 조건 j>=0&& a[j]>tmp에 해당하면.. 반복
  
  
    public static void main(String[] args) {
        Scanner stdIn = new Scanner(System.in);

        int nx = stdIn.nextInt();  📍배열 크기 정하기
        int[] x = new int[nx];     📍정한 크기의 배열 생성

        for (int i = 0; i < nx; i++) {  📍배열 개수만큼 값 for문 이용해서 자동으로 받아오기
            x[i] = stdIn.nextInt();
        }

        shellSort(x, nx);     📍배열 x와 배열 x의 길이값 nx를 shellSort 메소드로 실행      
        for (int i = 0; i < nx; i++)  📍실행된 값을 출력
            System.out.println("x[" + i + "]=" + x[i]);
    }
}

 
 ```
 ___
# 퀵 정렬 
the fastest

1. 피벗을 정해서 두 그룹으로 나누기
2. 왼쪽 끝에서 원하는 값과 오른쪽 끝에서 원하는 값의 위치를 바꾸
 
